import { storage } from "../storage.js"
import { db } from "../db.js"
import Stripe from "stripe"
import { stripeTransfers } from "../../shared/schema.js"
import { eq, and, lte, sql } from "drizzle-orm"
import type { StripeTransfer, InsertStripeTransfer } from "../../shared/schema.js"
import { VISUAL_PLATFORM_FEE, STRIPE_CONFIG } from "../../shared/constants.js"

// Lazy-init Stripe to avoid unsafe module-level initialization
let stripeInstance: Stripe | null = null

function getStripeInstance(): Stripe {
  if (!stripeInstance) {
    const secretKey = process.env.STRIPE_SECRET_KEY
    if (!secretKey) {
      throw new Error("STRIPE_SECRET_KEY environment variable is required for financial transfers")
    }

    stripeInstance = new Stripe(secretKey, {
      apiVersion: STRIPE_CONFIG.API_VERSION as any, // Configuration centralis√©e et configurable
    })
  }
  return stripeInstance
}

export interface ScheduleTransferOptions {
  userId: string
  amountCents: number
  referenceType: string
  referenceId: string
  description: string
  delayHours?: number
  metadata?: Record<string, any>
}

export class StripeTransferService {
  /**
   * PLANIFIER UN TRANSFERT STRIPE avec idempotence compl√®te
   * Garantit qu'aucun transfert en double ne sera cr√©√©
   */
  static async scheduleTransfer(options: ScheduleTransferOptions): Promise<StripeTransfer> {
    const {
      userId,
      amountCents,
      referenceType,
      referenceId,
      description,
      delayHours = VISUAL_PLATFORM_FEE.TRANSFER_DELAY_HOURS,
      metadata = {},
    } = options

    // Valider les param√®tres
    if (amountCents <= 0) {
      throw new Error(`Montant invalide: ${amountCents} centimes (doit √™tre positif)`)
    }
    if (amountCents > 100000) {
      // Limite s√©curit√© 1000‚Ç¨
      throw new Error(`Montant excessif: ${amountCents} centimes (limite: 100,000 centimes = 1000‚Ç¨)`)
    }

    // G√©n√©rer cl√© d'idempotence unique bas√©e sur la r√©f√©rence
    const idempotencyKey = `${referenceType}_${referenceId}_${userId}`

    // V√©rifier l'idempotence - transfert d√©j√† existant ?
    const existingTransfer = await this.getTransferByIdempotencyKey(idempotencyKey)
    if (existingTransfer) {
      console.log(`[STRIPE] ‚ö†Ô∏è Transfert d√©j√† programm√© avec cl√© ${idempotencyKey}: ${existingTransfer.id}`)
      return existingTransfer
    }

    // Calculer timestamp de traitement (d√©lai 24h par d√©faut)
    const scheduledProcessingAt = new Date()
    scheduledProcessingAt.setHours(scheduledProcessingAt.getHours() + delayHours)

    // Cr√©er l'enregistrement de transfert
    const transferData: InsertStripeTransfer = {
      idempotencyKey,
      status: "scheduled",
      amountCents,
      amountEUR: (amountCents / 100).toFixed(2),
      userId,
      referenceType,
      referenceId,
      scheduledProcessingAt,
      transferDescription: description,
      metadata: {
        ...metadata,
        scheduledDelayHours: delayHours,
        originalAmountCents: amountCents,
      },
    }

    const newTransfer = await storage.createStripeTransfer(transferData)
    console.log(
      `[STRIPE] üìÖ Transfert programm√©: ${amountCents} centimes pour ${userId} dans ${delayHours}h (${newTransfer.id})`,
    )

    return newTransfer
  }

  /**
   * TRAITER LES TRANSFERTS PROGRAMM√âS - appel√© par cron job
   * Traite tous les transferts dont l'heure de traitement est arriv√©e
   * Utilise une r√©clamation atomique pour √©viter les courses en concurrence
   */
  static async processScheduledTransfers(): Promise<{ processed: number; failed: number }> {
    console.log(`[STRIPE] üîÑ D√©marrage du traitement des transferts programm√©s...`)

    // R√©clamation atomique des transferts pr√™ts (passe de 'scheduled' √† 'processing')
    const claimedTransfers = await this.claimReadyTransfers()
    console.log(`[STRIPE] üìã ${claimedTransfers.length} transferts r√©clam√©s atomiquement`)

    let processed = 0
    let failed = 0

    for (const transfer of claimedTransfers) {
      try {
        await this.processIndividualTransfer(transfer)
        processed++
        console.log(`[STRIPE] ‚úÖ Transfert trait√© avec succ√®s: ${transfer.id}`)
      } catch (error) {
        failed++
        console.error(`[STRIPE] ‚ùå √âchec traitement transfert ${transfer.id}:`, error)
        await this.handleTransferFailure(transfer, error as Error)
      }
    }

    console.log(`[STRIPE] üìä Traitement termin√©: ${processed} r√©ussis, ${failed} √©checs`)
    return { processed, failed }
  }

  /**
   * TRAITER UN TRANSFERT INDIVIDUEL vers Stripe
   * Avec gestion compl√®te des erreurs et nouvelles tentatives
   */
  private static async processIndividualTransfer(transfer: StripeTransfer): Promise<void> {
    console.log(
      `[STRIPE] üöÄ Traitement transfert ${transfer.id}: ${transfer.amountCents} centimes vers ${transfer.userId}`,
    )

    // Le statut 'processing' est d√©j√† d√©fini atomiquement par claimReadyTransfers()
    try {
      const stripe = getStripeInstance()

      // R√©cup√©rer le compte Stripe Connect de l'utilisateur
      const userStripeAccount = await this.getUserStripeAccount(transfer.userId)
      if (!userStripeAccount) {
        throw new Error(`Utilisateur ${transfer.userId} n'a pas de compte Stripe Connect configur√©`)
      }

      // Cr√©er le transfert Stripe avec idempotence native de Stripe
      const stripeTransfer = await stripe.transfers.create(
        {
          amount: transfer.amountCents,
          currency: "eur",
          destination: userStripeAccount,
          description: transfer.transferDescription || `Transfert VISUAL ${transfer.referenceType}`,
          metadata: {
            visual_transfer_id: transfer.id,
            visual_reference_type: transfer.referenceType,
            visual_reference_id: transfer.referenceId,
            visual_user_id: transfer.userId,
          },
        },
        {
          idempotencyKey: transfer.idempotencyKey, // Idempotence native Stripe
        },
      )

      // Mettre √† jour avec les informations Stripe
      const destinationPayment =
        typeof stripeTransfer.destination_payment === "string"
          ? stripeTransfer.destination_payment
          : stripeTransfer.destination_payment?.id || ""
      await this.updateTransferCompleted(transfer.id, stripeTransfer.id, destinationPayment)

      console.log(`[STRIPE] üéâ Transfert Stripe cr√©√© avec succ√®s: ${stripeTransfer.id}`)
    } catch (error: any) {
      // Relancer l'erreur pour gestion par le processus appelant
      throw new Error(`Erreur transfert Stripe: ${error.message}`)
    }
  }

  /**
   * GESTION DES √âCHECS avec nouvelles tentatives automatiques
   */
  private static async handleTransferFailure(transfer: StripeTransfer, error: Error): Promise<void> {
    const maxRetries = 3
    const retryCount = (transfer.retryCount || 0) + 1

    if (retryCount <= maxRetries) {
      // Programmer une nouvelle tentative (d√©lai exponentiel)
      const retryDelayMinutes = Math.pow(2, retryCount - 1) * 30 // 30min, 1h, 2h
      const nextRetryAt = new Date()
      nextRetryAt.setMinutes(nextRetryAt.getMinutes() + retryDelayMinutes)

      await this.updateTransferForRetry(transfer.id, retryCount, nextRetryAt, error.message)
      console.log(
        `[STRIPE] üîÑ Nouvelle tentative programm√©e pour ${transfer.id} dans ${retryDelayMinutes} minutes (tentative ${retryCount}/${maxRetries})`,
      )
    } else {
      // √âchec d√©finitif apr√®s 3 tentatives
      await this.updateTransferStatus(transfer.id, "failed", error.message)
      console.error(
        `[STRIPE] üíÄ Transfert ${transfer.id} d√©finitivement √©chou√© apr√®s ${maxRetries} tentatives: ${error.message}`,
      )
    }
  }

  /**
   * M√âTHODES UTILITAIRES pour les op√©rations de base de donn√©es
   */
  private static async getTransferByIdempotencyKey(idempotencyKey: string): Promise<StripeTransfer | null> {
    try {
      const result = await db
        .select()
        .from(stripeTransfers)
        .where(eq(stripeTransfers.idempotencyKey, idempotencyKey))
        .limit(1)

      return result[0] || null
    } catch (error) {
      console.error(`[STRIPE] Erreur r√©cup√©ration transfert par cl√© ${idempotencyKey}:`, error)
      return null
    }
  }

  /**
   * R√©clamation atomique des transferts pr√™ts pour √©viter les courses en concurrence.
   * Cette m√©thode fait un UPDATE atomique qui passe de 'scheduled' √† 'processing'
   * et retourne uniquement les enregistrements qu'elle a r√©ussi √† r√©clamer.
   */
  private static async claimReadyTransfers(): Promise<StripeTransfer[]> {
    try {
      const now = new Date()

      // UPDATE atomique avec RETURNING pour r√©cup√©rer les transferts r√©clam√©s
      const claimedTransfers = await db
        .update(stripeTransfers)
        .set({
          status: "processing",
          updatedAt: new Date(),
        })
        .where(and(eq(stripeTransfers.status, "scheduled"), lte(stripeTransfers.scheduledProcessingAt, now)))
        .returning()

      console.log(`[STRIPE] üîí R√©clamation atomique de ${claimedTransfers.length} transferts pr√™ts`)
      return claimedTransfers
    } catch (error) {
      console.error(`[STRIPE] Erreur r√©clamation atomique des transferts:`, error)
      return []
    }
  }

  private static async updateTransferStatus(
    transferId: string,
    status: "scheduled" | "pending" | "processing" | "completed" | "failed" | "cancelled",
    failureReason?: string,
  ): Promise<void> {
    try {
      await db
        .update(stripeTransfers)
        .set({
          status,
          failureReason: failureReason || null,
          updatedAt: new Date(),
        })
        .where(eq(stripeTransfers.id, transferId))
    } catch (error) {
      console.error(`[STRIPE] Erreur mise √† jour statut transfert ${transferId}:`, error)
      throw error
    }
  }

  private static async updateTransferCompleted(
    transferId: string,
    stripeTransferId: string,
    stripeDestinationPaymentId: string,
  ): Promise<void> {
    try {
      await db
        .update(stripeTransfers)
        .set({
          status: "completed",
          stripeTransferId,
          stripeDestinationPaymentId,
          processedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(stripeTransfers.id, transferId))
    } catch (error) {
      console.error(`[STRIPE] Erreur finalisation transfert ${transferId}:`, error)
      throw error
    }
  }

  private static async updateTransferForRetry(
    transferId: string,
    retryCount: number,
    nextRetryAt: Date,
    failureReason: string,
  ): Promise<void> {
    try {
      await db
        .update(stripeTransfers)
        .set({
          status: "scheduled", // Repasser en scheduled pour nouvelle tentative
          retryCount,
          nextRetryAt,
          failureReason,
          scheduledProcessingAt: nextRetryAt, // Reprogrammer √† l'heure de nouvelle tentative
          updatedAt: new Date(),
        })
        .where(eq(stripeTransfers.id, transferId))
    } catch (error) {
      console.error(`[STRIPE] Erreur programmation nouvelle tentative ${transferId}:`, error)
      throw error
    }
  }

  /**
   * R√âCUP√âRER LE COMPTE STRIPE CONNECT d'un utilisateur
   */
  private static async getUserStripeAccount(userId: string): Promise<string | null> {
    console.log(`[STRIPE] üîç Recherche compte Stripe Connect pour utilisateur ${userId}`)

    try {
      const user = await storage.getUser(userId)

      if (!user?.stripeConnectAccountId) {
        throw new Error(`Utilisateur ${userId} n'a pas de compte Stripe Connect configur√©`)
      }

      if (!user.stripeConnectOnboarded || !user.stripeConnectPayoutsEnabled) {
        throw new Error(
          `Compte Stripe Connect ${user.stripeConnectAccountId} non compl√®tement configur√© (onboarded: ${user.stripeConnectOnboarded}, payouts: ${user.stripeConnectPayoutsEnabled})`,
        )
      }

      return user.stripeConnectAccountId
    } catch (error) {
      console.error(`[STRIPE] Erreur r√©cup√©ration compte Connect:`, error)
      throw error
    }
  }

  /**
   * M√âTHODES PUBLIQUES pour int√©gration avec d'autres services
   */

  /**
   * Planifier un transfert TOP10 avec idempotence
   */
  static async scheduleTop10Transfer(
    userId: string,
    amountCents: number,
    referenceType: "top10_infoporteur" | "top10_winner",
    referenceId: string,
    rank?: number,
  ): Promise<StripeTransfer> {
    const description =
      referenceType === "top10_infoporteur"
        ? `Redistribution TOP10 - Rang ${rank || "N/A"}`
        : `Redistribution TOP10 - Investi-lecteur`

    return this.scheduleTransfer({
      userId,
      amountCents,
      referenceType,
      referenceId,
      description,
      metadata: {
        top10_rank: rank,
        transfer_type: "top10_redistribution",
      },
    })
  }

  /**
   * Planifier un transfert de conversion VISUpoints
   */
  static async scheduleVisuPointsTransfer(
    userId: string,
    amountCents: number,
    visuPointsAmount: number,
    referenceId: string,
  ): Promise<StripeTransfer> {
    return this.scheduleTransfer({
      userId,
      amountCents,
      referenceType: "visupoints_conversion",
      referenceId,
      description: `Conversion VISUpoints vers EUR (${visuPointsAmount} VP)`,
      metadata: {
        visupoints_amount: visuPointsAmount,
        conversion_rate: VISUAL_PLATFORM_FEE.VISUPOINTS_TO_EUR,
        transfer_type: "visupoints_conversion",
      },
    })
  }

  /**
   * Obtenir le statut d'un transfert
   */
  static async getTransferStatus(transferId: string): Promise<StripeTransfer | null> {
    try {
      const result = await db.select().from(stripeTransfers).where(eq(stripeTransfers.id, transferId)).limit(1)

      return result[0] || null
    } catch (error) {
      console.error(`[STRIPE] Erreur r√©cup√©ration transfert ${transferId}:`, error)
      return null
    }
  }

  /**
   * Obtenir tous les transferts d'un utilisateur
   */
  static async getUserTransfers(userId: string): Promise<StripeTransfer[]> {
    try {
      const result = await db
        .select()
        .from(stripeTransfers)
        .where(eq(stripeTransfers.userId, userId))
        .orderBy(sql`${stripeTransfers.createdAt} DESC`)

      return result
    } catch (error) {
      console.error(`[STRIPE] Erreur r√©cup√©ration transferts utilisateur ${userId}:`, error)
      return []
    }
  }
}
